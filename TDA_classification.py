# Created by Aurelia Li, Adsorption and Advanced Materials Group (aam.ceb.cam.ac.uk),
# led by David Fairen-Jimenez from the Department of Chemical Engineering and
# Biotechnology, University of Cambridge.

"""
Step 4 - classification of the TDA landscapes
"""
## Part IVa - hierarchical clustering

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os

# Read in list of structures of interest
path_to_GCD = 'GCD.gcd' # MODIFY THIS IF NECESSARY
gcd_list = open(path_to_GCD, 'r').read()
refcodes = gcd_list.split("\n")

# Create list of indices for pandas dataframe (not using the refcodes list
# in case something wrong happens)
indices = []
shapes = {}

# Check the shapes of the structures landscapes
for refcode in refcodes:
    try:
        if os.path.exists(refcode+".npy"):
            with open(refcode+".npy", 'rb') as f:
                L = np.load(f)
                shapes[refcode] = L.shape
            indices.append(refcode)
    except:
        print("issue with", refcode)

# Create a master array where each row is a landscape. Length is that of L.
length = shapes[refcodes[0]][1]
master = np.empty((1, length)) 

indices = []
for refcode in shapes.keys():
    if shapes[refcode][1] == length:
        with open(refcode+".npy", 'rb') as f:
            L = np.load(f)
            master = np.vstack([master, L])
            indices.append(refcode)

# Remove first row of approx zeros generated by np.empty
master = np.delete(master, 0, 0)

# create list of columns for pandas dataframe
columns = []
for i in range(int(length/2)):
    columns.append("dimension 1 " + str(i))
for i in range(int(length/2)):
    columns.append("dimension 2 " + str(i))

# Convert to pandas dataframe and save
panda_master = pd.DataFrame(data=master, index=indices, columns=columns)
panda_master.to_csv('cages_final.csv')

# Computing dendrogram
from scipy.cluster.hierarchy import dendrogram, linkage, fcluster

# Compute linkage
Z = linkage(panda_master, 'ward')

# plot dendrogram
plt.figure()
plt.title("Dendrograms")
dendrogram = dendrogram(Z)
max_d = 0.06 # MODIFY THIS ACCORDING TO DENDROGRAM
# Cutting the dendrogram at max_d
plt.axhline(y=max_d, c='k')

# See number of clusters k
k=3 # MODIFY THIS ACCORDING TO NUMBER OF CLUSTERS OBSERVED ON DENDROGRAM
clusters = fcluster(Z, k, criterion='maxclust')

# Then assemble data into a dataframe with refcodes and the corresponding predicted class
labeled = np.array([indices, clusters])
labeled = labeled.T
labeled_pd = pd.DataFrame(data = labeled, columns =['refcode', 'class'])

## Part IVb - Random forest

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn import metrics

# importing dataframe and selecting columns
dataset=pd.read_csv('cages_final.csv')
dataset.head()

X = dataset.iloc[:-1,1:-1]
Y = dataset.iloc[:-1,-1:]
Y = Y.values.ravel()

# setting an out-split to validate performance after cv
X_cv, X_out,Y_cv, Y_out = train_test_split(X,Y,test_size=0.15, random_state=42)

#Base model
clf=RandomForestClassifier(n_estimators=100, random_state=75)
clf.fit(X_cv, Y_cv)
Y_pred=clf.predict(X_out)
all_pred=clf.predict(X)

print("Accuracy:",metrics.accuracy_score(Y_out, Y_pred))
print('Mean Absolute Error:', metrics.mean_absolute_error(Y_out, Y_pred))
print('Mean Squared Error:', metrics.mean_squared_error(Y_out, Y_pred))
print('Root Mean Squared Error:', np.sqrt(metrics.mean_squared_error(Y_out, Y_pred)))
print('R Squared:', metrics.r2_score(Y_out, Y_pred))
